# 用于桥梁病害分析研究
#在上一个版本基础上，更改为可遍历不同excel文件夹,将病害识别部分改造为模块
# v5增加桥梁联跨信息
# V6对防止联跨信息重复做了规避，只要改变高速名称，disease analysis程序通用
# v7_jinghu 增加桥梁曾用名匹配,京沪高速专用
from openpyxl import load_workbook
import os
import re
import difflib # 用于比较两个字符串相似度的模块
import imod_split  #自制数据识别拆分模块

spaninfo_dir0=r'E:\工作\02 控股公司\预防性养护\病害分析\python分析\联跨信息\京沪组合箱梁桥联跨信息'
spanlist=[] #list of span and couplet info
spanlist_dir0=os.listdir(spaninfo_dir0)
spancolumn_names=['bridge_id','bridge_name','direction','span_num','couplet_num',
                      'couplet_span_quantity','couplet_span_num','span_length'] #定义所有列名，也就是字典中的所有键名       
for spanfile in spanlist_dir0:
    if '~$' not in spanfile: # 文件夹经常出现临时文件
        spandata=load_workbook(spaninfo_dir0+'\\'+spanfile) #获得工作薄对象，工作目录里面的某个文件
        print('读取  '+spanfile+'  成功!')
        sheetnames0=spandata.sheetnames #获得所有表名
        sheet0=spandata[sheetnames0[0]] #获得第一张表对象
        spancolumn_names=['bridge_id','bridge_name','direction','span_num','couplet_num',
                      'couplet_span_quantity','couplet_span_num','span_length'] #定义所有列名，也就是字典中的所有键名
        spandataint=[] #新建存储数据用的列表，所有数据，列表中每一
        for row_num in range(2,sheet0.max_row+1):
            data_row={} #存储某一行数据用的字典 这个位置非常重要
            okay=sheet0.cell(row=row_num,column=4).value
            if okay:
                for column_num in range(1,9):
                    data_row[spancolumn_names[column_num-1]]=sheet0.cell(row=row_num,column=column_num).value      
                spandataint.append(data_row)
        spanlist.extend(spandataint)
        
############   ###################
highway_dir0=r'E:\工作\02 控股公司\预防性养护\病害分析\python分析\报告数据提取结果Excel\京沪高速'
#uperstruc_int=[] #看看到底用了哪些词语来描述上部结构
#读取一个工作簿
superdata=[] # 所有数据
list_dir0=os.listdir(highway_dir0)  # 遍历所有年份文件夹
column_names=['highway','year_check','year_open','bridge_id','bridge_name',
            	'direction_span_num','uperstruc','substruc','weather','disease_location',
                'disease_condition','couplet_num','couplet_span_quantity','couplet_span_num',
            	'span_length','maintain_time','maintain_way'] #定义所有列名，也就是字典中的所有键名
            
for highway_dir in [list_dir0[1]]:
    list_dir=os.listdir(highway_dir0+'\\'+highway_dir) # 遍历所有excel文件
    for filename in list_dir:
        if '~$' not in filename: # 文件夹经常出现临时文件
            data=load_workbook(highway_dir0+'\\'+highway_dir+'\\'+filename) #获得工作薄对象，工作目录里面的某个文件
            print('读取  '+highway_dir+'  '+filename+'  成功!')
            sheetnames=data.sheetnames #获得所有表名
            sheet=data[sheetnames[0]] #获得第一张表对象
                       
            if sheet.max_row>1:
                
                #### 把excel表中的数据读出来放在list中，list的每一个元素为字典，该字典存储了原来excel表的一行数据
                dataint=[] #新建存储数据用的列表，所有数据，列表中每一，每个excel文件一个datint
                for row_num in range(2,sheet.max_row+1):
                    data_row={} #存储某一行数据用的字典 这个位置非常重要
                    for column_num in range(1,sheet.max_column+1):
                        data_row[column_names[column_num-1]]=sheet.cell(row=row_num,column=column_num).value
                    
                    # 拆分检查部位 direction_span_num 拆分为  方向=“direction”  跨号=“span_num”
                    direction_span_num=data_row['direction_span_num']
                    
                    direction_span_num=direction_span_num.replace('右幅','上行')
                    direction_span_num=direction_span_num.replace('京沪','上行')
                    direction_span_num=direction_span_num.replace('左幅','下行')
                    direction_span_num=direction_span_num.replace('沪京','下行')
                    
                    
                    
                    pattern1=r'(上行|下行)第?(\d+)联第?(\d+)孔\S*'
                    pattern2=r'(上行|下行)第?(\d+)孔\S*'
                    pattern3=r'第?(\d+)联第?(\d+)孔\S*'
                    pattern4=r'第?(\d+)孔\S*'
                    
                    pattern=pattern1
                    match=re.match(pattern,direction_span_num)
                    direction=''
                    span_num=''
                    if match:
                        direction=match.group(1) # 方向
                        couplet_num=match.group(2)
                        couplet_span_num=match.group(3) # 
                    else:
                        pattern=pattern2
                        match=re.match(pattern,direction_span_num)
                        if match:
                             direction=match.group(1)
                             span_num=match.group(2)
                        else:
                             pattern=pattern3
                             match=re.match(pattern,direction_span_num)
                             if match:
                                 direction='无'
                                 couplet_num=match.group(1)
                                 couplet_span_num=match.group(2)
                             else:
                                 pattern=pattern4
                                 match=re.match(pattern,direction_span_num)
                                 if match:
                                     direction='无'
                                     span_num=match.group(1)
                                 else:
                                     print('检查部位描述错误  '+direction_span_num)
                                     continue
                        
                    del data_row['direction_span_num']
                    data_row['span_num']=span_num
                    data_row['direction']=direction
                    
                    k=data_row['disease_location']
                    v=data_row['disease_condition']
                    s=data_row['uperstruc']
                    #if s not in uperstruc_int:
                        #uperstruc_int.append(s)
                    bridge_name=data_row['bridge_name']
                    direction=data_row['direction']
                        
                    span_num=data_row['span_num']
                    itsme=0 #判断组合箱梁是否匹配成功
                    for span in spanlist:
                        if bridge_name:
                            seq=difflib.SequenceMatcher(None, span['bridge_name'], bridge_name)
                            ratio=seq.ratio() #桥梁名称相似度
                            if ratio>0.88 and span['direction']==direction and span['span_num']==int(span_num):                                   
                                itsme=1
                                if ratio<1:
                                    data_row['bridge_name']=span['bridge_name']
                                    print(span['bridge_name']+'  曾用名  '+bridge_name+'  相似度：'+str(ratio)) 
                                #print('匹配成功')
                                if '腹板' in k or '底板' in k or '翼缘' in k:
                                    #if '组合箱' in s or '部分' in s:
                                    if '裂缝' in v and '修补' not in v:  
                                        data_row['couplet_num']=span['couplet_num']
                                        data_row['couplet_span_quantity']=span['couplet_span_quantity']
                                        data_row['couplet_span_num']=span['couplet_span_num']
                                        data_row['span_length']=span['span_length']

                                        dataint.append(data_row)
                                        
                                        break   #找到一个即跳出，防止联跨信息有重叠，提高效率
                                
                    #if itsme==0 and ('组合箱' in s or '部分' in s):  #增加一个判断，防止由于桥梁名称错误，组合箱梁漏计入
                        #print('联跨信息或桥梁名称有误  '+data_row['bridge_name']+'  '+data_row['direction']+data_row['span_num']+s)
                
                ### 识别拆解提取数据
                data_plus=[]   #一条记录包含两条病害的，进行拆分后另存
                data_row={}
                for data_row in dataint:    # data_row会自动关联dataint里面所有一样的数据！！！！
                
                    
                    # 拆分缺损位置 disease_location 拆分为 member refer1 x1 x2 unit1 refer2 y1 y2 unit2
                    # 参数初始化
                    refer1=''
                    x1=''
                    x2=''
                    loc_unit1=''
                    refer2=''
                    y1=''
                    y2=''
                    loc_unit2=''
                    
                    disease_location=data_row['disease_location']
                    split=re.split('距',disease_location)
                    member=split[0] # 构件
                    if len(split)==2:
                        distance1=split[1]
                        (refer1,x1,x2,loc_unit1)=imod_split.location(distance1)
                    elif len(split)==3:
                        distance1=split[1]
                        (refer1,x1,x2,loc_unit1)=imod_split.location(distance1)    
                        distance2=split[2]
                        (refer2,y1,y2,loc_unit2)=imod_split.location(distance2)
                    elif len(split)>3:
                        print('缺损位置描述有误，距太多！')    
                        
                    data_row['member']=member
                    data_row['refer1']=refer1
                    data_row['x1']=x1
                    data_row['x2']=x2
                    data_row['loc_unit1']=loc_unit1
                    
                    data_row['refer2']=refer2
                    data_row['y1']=y1
                    data_row['y2']=y2
                    data_row['loc_unit2']=loc_unit2
                    
                    del data_row['disease_location']
                    
                    # 拆分缺损状况 disease_condition 拆分为 dis_num dis_type dis_attr1 dis_value1 dis_unit1 dis_attr2 dis_value2 dis_unit2
                    dis_num=''
                    dis_type=''
                    dis_attr1=''
                    dis_value1=''
                    dis_unit1=''
                    dis_attr2=''
                    dis_value2=''
                    dis_unit2=''
                    
                    disease_condition=data_row['disease_condition']
                    
                    if '&&' not in disease_condition:
                        (dis_num,dis_type,dis_attr1,dis_value1,dis_unit1,dis_attr2,dis_value2,dis_unit2)=imod_split.condition_crack(disease_condition)
                        
                        data_row['dis_num']=dis_num
                        data_row['dis_type']=dis_type
                        data_row['dis_attr1']=dis_attr1
                        data_row['dis_value1']=dis_value1
                        data_row['dis_unit1']=dis_unit1
                        data_row['dis_attr2']=dis_attr2
                        data_row['dis_value2']=dis_value2
                        data_row['dis_unit2']=dis_unit2
                        
                        del data_row['disease_condition']
                    else:
                        split=re.split('&&',disease_condition) #拆分出之前合并的两个病害
                        num=0
                        for disease_condition_cell in split:
                            data_row_plus={}
                            if '向裂缝' in disease_condition_cell:  #筛选出裂缝类病害
                                num=num+1
                                (dis_num,dis_type,dis_attr1,dis_value1,dis_unit1,dis_attr2,dis_value2,dis_unit2)=imod_split.condition_crack(disease_condition)          
                                if num==1:    #第一个病害                            
                                    data_row['dis_num']=dis_num
                                    data_row['dis_type']=dis_type
                                    data_row['dis_attr1']=dis_attr1
                                    data_row['dis_value1']=dis_value1
                                    data_row['dis_unit1']=dis_unit1
                                    data_row['dis_attr2']=dis_attr2
                                    data_row['dis_value2']=dis_value2
                                    data_row['dis_unit2']=dis_unit2   
                                    
                                    del data_row['disease_condition']
                                else: #其他病害另外存储
                                    data_row_plus=data_row                       
                                    
                                    data_row_plus['dis_num']=dis_num
                                    data_row_plus['dis_type']=dis_type
                                    data_row_plus['dis_attr1']=dis_attr1
                                    data_row_plus['dis_value1']=dis_value1
                                    data_row_plus['dis_unit1']=dis_unit1
                                    data_row_plus['dis_attr2']=dis_attr2
                                    data_row_plus['dis_value2']=dis_value2
                                    data_row_plus['dis_unit2']=dis_unit2                                  
                                    
                                    data_plus.append(data_row_plus)
                superdata.extend(dataint) # 数据集成到superdata中
                superdata.extend(data_plus)   

# 数据存储下来
from openpyxl import Workbook
wb=Workbook()
ws=wb.active

title_excel=[]
for k,v in superdata[0].items():
    title_excel.append(k)
    
ws.append(title_excel) # 表头加入excel表中
filename_xlsx='沿海组合箱梁桥病害-含联跨信息.xlsx' # 更换文件后缀名作为新生成的excel文件的名称
for dict_table in superdata:
    # 把每条病害数据
    newRow=[]
    for k,v in dict_table.items():
        newRow.append(v)
        #print(newRow)
    ws.append(newRow)
wb.save(highway_dir0+'\\'+filename_xlsx)
print('存储xlsx成功！')     

                
                            
                    
                
    












        
        
